import copy, random, re

STRING_QUOTE = '"'
VECTOR_OPEN="{"
VECTOR_CLOSE="}"
def to_language(value):
    """
    Return `value` as a string representing a C++ constant

    .. TODO:: make the output language configurable

        >>> to_language(3)
        '3'
        >>> to_language("alice")
        '"alice"'
        >>> to_language([1,2,3])
        '{1, 2, 3}'
        >>> to_language([[1,2],["alice", "bob"]])
        '{{1, 2}, {"alice", "bob"}}'
    """
    if isinstance(value, str):
        return STRING_QUOTE + value + STRING_QUOTE
    elif isinstance(value, list):
        return VECTOR_OPEN + ", ".join(to_language(v) for v in value) + VECTOR_CLOSE
    else:
        return str(value)

def RANDOM_INT(min, max):
    r"""
    Return a random integer between `min` and `max` included.

        >>> RANDOM_INT(3,5)     # doctest: +SKIP
        4

        >>> RANDOM_INT(3,3)
        3
    """
    return random.randint(min, max)

def RANDOM_CHOICE(*args):
    r"""
    Return a random element of `args`

        >>> RANDOM_CHOICE("alice", "bob", "charlie")  # doctest: +SKIP
        'charlie'

        >>> RANDOM_CHOICE("alice")
        'alice'
    """
    return random.choice(args)

def RANDOM_VECTOR(n, generator, *args):
    r"""
    Return a random vector of length `n` and whose elements are
    generated by calling `generator(*args)`

    This return a random vector of integers of length 5, with
    elements between 1 and 3:

        >>> RANDOM_VECTOR(5, RANDOM_INT, 1, 3) # doctest: +SKIP
        [3, 1, 2, 1, 3]

        >>> RANDOM_VECTOR(5, RANDOM_INT, 1, 1)
        [1, 1, 1, 1, 1]
    """
    return [generator(*args) for i in range(n)]

locals = {
    "RANDOM_INT": RANDOM_INT,
    "RANDOM_CHOICE": RANDOM_CHOICE,
    "RANDOM_VECTOR": RANDOM_VECTOR,
    "PLUSOUMOINS": PLUSOUMOINS
}

test_code = """CONST N = RANDOM_INT(3,3);
CONST M = RANDOM_INT(4,4);
CONST V = RANDOM_VECTOR(N, RANDOM_INT, 5, 5);
CONST VV = RANDOM_VECTOR(N, RANDOM_VECTOR, M, RANDOM_INT, 1, 1);
int main () {
    int a = N + M;
    vector<int> v = V;
    vector<vector<int>> vv = VV;
}"""


def randomize_code(code):
    r"""

        >>> import random
        >>> random.seed(0)
        >>> randomize_code("int XX=3;")
        'int XX=3;'
        >>> randomize_code("int X=3; int Y=4; int Z=5;")
        'int y=3; int x=4; int z=5;'
        >>> randomize_code("I, J, K, N")
        'j, k, n, i'
        >>> randomize_code("CI1, CI2, CI3, CI4, CI5")
        '-2, -1, 2, 1, 0'
        >>> randomize_code("int X=1;\nint Y=CI2;")
        'int x=1;\nint y=2;'

        >>> print(test_code)
        CONST N = RANDOM_INT(3,3);
        CONST M = RANDOM_INT(4,4);
        CONST V = RANDOM_VECTOR(N, RANDOM_INT, 5, 5);
        CONST VV = RANDOM_VECTOR(N, RANDOM_VECTOR, M, RANDOM_INT, 1, 1);
        int main () {
            int a = N + M;
            vector<int> v = V;
            vector<vector<int>> vv = VV;
        }
        >>> print(randomize_code(test_code))
        int main () {
            int a = 3 + 4;
            vector<int> v = {5, 5, 5};
            vector<vector<int>> vv = {{1, 1, 1, 1}, {1, 1, 1, 1}, {1, 1, 1, 1}};
        }
    """
    consts = {}
    consts['X'],consts['Y'],consts['Z'] = random.sample('xyz',3)
    consts['I'],consts['J'],consts['K'],consts['N'] = random.sample('ijkn',4)
    consts['PLUSOUMOINS'] = str(random.choice(['+', '-']))
    consts['CI1'] = str(random.randint(-2,2))
    consts['CI2'] = str(random.randint(-2,2))
    consts['CI3'] = str(random.randint(-2,2))
    consts['CI4'] = str(random.randint(0,3))
    consts['CI5'] = str(random.randint(0,1))

    result = []
    for line in code.splitlines():
        pattern = re.compile(r'\b(' + '|'.join(consts.keys()) + r')\b')

        match = re.match(r"CONST (\w+) = (.*?);?$", line)
        if match:
            # Define new constant
            variable, value = match.groups()
            value = pattern.sub(lambda i: consts[i.group()], value)
            consts[variable] = to_language(eval(value, {}, locals))
        else:
            line = pattern.sub(lambda i: consts[i.group()], line)
            result.append(line)
    return "\n".join(result)

def split_code(code):
    r"""
        Split the code in chunks according to BEGIN / END markers

        >>> code = '''foo code 1
        ... foo code 1b
        ... /// BEGIN A
        ... foo A
        ... foo Ab
        ... /// END A
        ... foo code 2
        ... /// BEGIN B
        ... foo B
        ... /// END B
        ... /// BEGIN C
        ... foo C
        ... /// END C
        ... foo code 3
        ... '''
        >>> split_code(code)                 # doctest: +NORMALIZE_WHITESPACE
        [{'content': 'foo code 1\nfoo code 1b\n', 'type': 'default'},
         {'content': 'foo A\nfoo Ab\n',           'type': 'a'},
         {'content': 'foo code 2\n',              'type': 'default'},
         {'content': 'foo B\n',                   'type': 'b'},
         {'content': 'foo C\n',                   'type': 'c'},
         {'content': 'foo code 3\n',              'type': 'default'}]

    """
    begin_or_end = re.compile(r'\s*/// (BEGIN|END) (\w+)')
    loose_begin_or_end = re.compile('BEGIN|END')
    items = []
    item = {'content': '', 'type': 'default'}
    for line in code.splitlines():
        match = begin_or_end.match(line)
        if match:
            if item['content']:
                items.append(item)
            type = match.group(2).lower()
            if match.group(1) == 'BEGIN':
                item = {'content': '', 'type': type}
            else:
                if type != item['type']:
                    raise ValueError("END `{}` does not match BEGIN `{}`".format(type, item['type']))
                item = {'content': '', 'type': 'default'}
            continue
        assert not loose_begin_or_end.search(line)
        item['content'] += line + "\n"
    if item['content']:
        items.append(item)
    return items

def insert_answer_items(items):
    r"""
    Insert an answer item after each solution item.

        >>> items = [{'type':'default'}, {'type':'solution'}, {'type':'default'}, {'type':'solution'}, {'type':'solution'}]
        >>> insert_answer_items(items)
        [{'type': 'default'},
         {'type': 'solution'}, {'type': 'answer'},
         {'type': 'default'},
         {'type': 'solution'}, {'type': 'answer'},
         {'type': 'solution'}, {'type': 'answer'}]
    """
    res = []
    for item in items:
        res.append(item)
        if item['type'] == 'solution':
            res.append({'type': 'answer'})
    return res

def build_generic(exo):
    r"""
    Generic exercise builder

    This builder is in charge of:

    - making a deep copy of `exo` to make sure the exercise building
      is purely functional and avoid side effects when calling several
      times the same exercise;
    - setting the exercise title;
    - doing some cleanup;
    - fetching the code from exo['code'] or the file exo['code_file']
    - randomizing the code;
    - splitting the code into items of various types according to the
      annotations (default, hidden, solution, answer).

    An additional step is required to set the html input field name
    for each item that is an answer. This can't be done here because
    the exercise builder may later insert answer items in additions to
    those already specified in the code. This is therefore postponed to
    a separate function `build_finalize`.

    The exercise builder should therefore:
    - filter `exo` through `build_generic`
    - do its own magic, modifying `exo` in place if so it wishes
    - filter `exo` through `build_finalize`

        >>> import graderCpp, builder
        >>> exo = build_generic({'code': graderCpp.test_code_generic,
        ...                     'seed': 34,
        ...                     'typename':'foo',
        ...                     'topicname':'bar',
        ...                     'solution_failure_message': ' '
        ...                     })
        >>> exo['title']
        'foo: bar'
        >>> exo['items']
        [{'content': '#include<iostream>\nint main() {\n', 'type': 'hidden'},
         {'content': '     int i;\n', 'type': 'default'},
         {'content': '     i = 42;\n', 'type': 'solution'},
         {'type': 'answer'},
         {'content': '     std::cout << i << std::endl;\n', 'type': 'default'},
         {'content': '}\n', 'type': 'hidden'}]
         >>> len(exo['solution_failure_message'])
         0
    """
    exo = copy.deepcopy(exo)
    # For some reason, empty values in the PL file are stored as strings of length 1
    for key in ['solution_failure_message', 'answer_failure_message']:
        if key in exo:
            exo[key] = exo[key].strip()
    random.seed(exo['seed'])
    exo['title'] = "{typename}: {topicname}".format(typename=exo['typename'], topicname=exo['topicname'])
    code = exo.get('code')
    if code is None:
        with open(exo['code_file']) as f:
            code = f.read()
    code = randomize_code(code)
    exo['items'] = insert_answer_items(split_code(code))
    return exo

def build_finalize(exo):
    r"""
    Set the input field name for each item that is an answer.

    .. WARNING:: at this stage the input `exo` is modified in place
    """
    i = 0
    for item in exo['items']:
        if item['type'] == 'answer':
            if i > 0:
                raise NotImplementedError("Only one answer field is supported for now")
            item['key'] = "answer"
            #item['key'] = "answer{}".format(i)
            i += 1
    return exo




