
author=Dominique dot Revuz dot u-pem dot fr 
title= Des identifiants en C

introduction==

Les règles de construction des identificateurs.

Les caractères autorisés sont '0' à '9','a' à 'z','A' à 'Z', et le souligné '_'. 

Règle suplémentaire : pas de chiffre en première position.

Règle supplémentaire : certain mots sont réservé pour le langage et ne doivent pas être utilisé comme identifiants (votre éditeur doit les affichez en gras).

	asm 	 permet d'inclure du code assembleur directement dans le code source C. 
	auto 	 permet d'indiquer l'allocation sur la pile (par défaut). 
	break 	 permet d'interrompre une boucle ou une instruction «switch».
	case 	 permet d'identifier un cas dans un branchement «switch». 
	char 	 identifie le type de données de caractère.
	const 	 permet de définir une constante.
	continue 	 permet de passer à l'itération suivante d'une boucle.
	default 	 permet d'exécuter cas par défaut des branchement «switch».
	do 	 première partie d'une boucle  «do while».
	double 	 identifie le type de données réel en double précision.
	else 	 branchement sinon des conditionelle «if». 
	enum 	 permet de définir un type de données d'énumération.
	extern 	 permet de déclarer une variable externe au fichier.
	float 	 permet d'identifier le type de données de «float». 
	for 	 permet d'effectuer un compteur de boucle.
	goto 	 permet de faire un saut d'exécution à une étiquette. 	ISO C99

	if 	 permet d'effectuer le traitement d'une condition. 	ISO C99
	inline 	 permet d'indiquer qu'il faut que le compilateur élargisse la fonction en ligne au moment de l'appel de la fonction ou d'un membre de fonctions 	ISO C99
	int 	 identifie le type de données d'entier. 	ISO C99
	long 	 identifie le type de données d'entier long. 	ISO C99

	register 	 permet d'indiquer qu'il faut utiliser autant que possible les registres du microprocesseur pour contenir le contenu d'une variable ou d'un paramètre. 	ISO C99

	return 	 permet de définir la valeur de retour d'une fonction et de terminer celle ci.
	short 	 identifie le type de données d'entier court.
	signed 	 permet d'indiquer que le type de données est entier et qu'il support les nombres négatif.
	sizeof 	 permet d'optenir la taille d'un type.
	static 	 permet de limiter la visibilité d'une fonction au fichier courrant, ou a globaliser une variable locale.
	struct 	 permet d'identifier une structure de donnée à plusieurs champs.
	switch 	 permet un branchement multiple. 
	typedef 	 permet de définir un type utilisateur.
	union 	 permet de définir plusieurs types pour une même zone mémoire.
	unsigned 	 permet d'indiquer que le type de données ne contient pas de bit de signe.
	void 	 permet de définir un type n'ayant aucun type. 
	volatile 	 permet d'indiquer que la variable peut être modifiée par une autre activité (ou un autre processus dans certains cas, elle n'est pas fiable ...).
	while 	 permet de définir une boucle.


Attention quand vous ajouter des fichiers ".h" du système comme <stdio.h> il y a des noms déja utilisés dans ces fichiers qu'il n'est pas possible de réutiliser. EN particulier les nom de Macros qui peuvent créer des effets bizarres.



==

concept==identifiants
@ cbank:/exercices/type/qcm_questions/identifiants.pl
@ cbank:/exercices/type/qcm_questions/identifiants1.pl
@ cbank:/exercices/type/qcm_questions/identifiants2.pl
@ cbank:/exercices/type/qcm_questions/identifiants3.pl
==
